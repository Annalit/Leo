
嗯
   
OK

那么对于sum[i]，假设我们知道所有sum[0]到sum[i-1]的值，我们怎么求sum[i]？
加上num[i]或者不加num[i]?

对于sum[i]的定义是以num[i]作为结尾的最大子数组和，所以有不加上num[i]的这种可能吗？ 根据我们的定义？
看错了。。我看看
那就是加上sum[i-1]+num[i] 或者num[i]?

Exactly，我们现在要求最大，所以只要取这两种可能的最大值就好了
这样对于sum[i]的最大值就求出来了
然后？

那现在我们只是求出了以sum[i]作为结尾的最大子数组和，那么按照QQ上的转换后的原问题的定义，我们只要取所有sum的最大值是不是就是全局最大值了？
怎么想到sum[i]的。。

一般来说，动态递归就是recursion without repetition。你要不先找到问题的一种分割方式，或者看看问题本身有没有什么递归结构。比如说这题，  你想想子数组是不是一个递归结构
你说的是sum[i] 和sum[i-1]的关系？
Exactly，还有其他的例子比如子序列也是一样的
无后效应
这个体现在哪里，是说sum[i]只需要知道sum[i-1]就够了的意思？

你说

不一定只是这样，比如如果在算sum[i]的时候需要sum[i-1], sum[i-2]之类的好几个之前的状态，这样也是无后效性的体现。因为像之前说的，计算当前状态只依赖于之前计算过的状态
就是不依赖于未来的意思是吧
可以这么理解
那那个什么最优子结构。。说的是sum[i]最优的前提是sum[i-1]最优么
没错
可是这样我会和贪心搞混。。不是说全局最优不一定局部最优什么什么的么。。
是的。我们这个问题的全局最优就是要查看所有算过的解才能决定的啊

那重叠子问题指的就是说。。sum[i],sum[i-1]长的一样的意思？
具体来说，本来算sum[i]我们要查看所有之前的sum值，但是按照我们的计算顺序以及状态定义，sum[i-1]已经把大部分的计算工作做好了，所以我们直接利用这个结果。
我想起来我哪里晕了。。对了。。这个。。一般动态规划的解就是最终的状态值，但是这题如果是用sum[i]来画状态图的话，其实，到最后的max，好像，不太一样。。你知道我在说什么么。。。。。就是感觉一般的答案
你的意思是你在做这题时候想的是一种状态定义，但是算的时候用的是另外一种转移方式，然后发现这两者之间不一致，导致晕了，是吗？
就是感觉一般动态规划。。书上都会说f(n) = f(n-1)&%*%$^%,然后画一个二维矩阵，矩阵的左下角，就是f(n)，就是这题答案了。。然后就会说根据答案来定义状态啊，然后把图填满，还有最优子路径啊什么的，但是这题如果用sum[i]，是不是最优子路径还要另外求。。我好像又说晕了。。

最优路径是另外一个问题，如果你这题要求，也很简单，在状态转移的时候，只要同时记录下当前状态是从哪个之前的状态转移过来的就可以构造出整个最优解的对应路径出来了
你说的状态是说sum[i]?
我总有一种。。因为这道题要求max，就弄一个max[i]当状态的错觉。。我觉得这大概就是我混乱的地方，就像这题我一开始以为max才是状态转移方程，你跟我讲了之后我才发现好像sum[i]才是。。

我也可以从你的状态定义来讲，按照你的定义，一个是max[i]表示nums[0]到nums[i]的最大子数组和，是吧

嗯

好，那么假设我们知道所有max[0]到max[i-1]的值，我们现在要求max[i]，根据我们对于max数组的定义，这个状态方程应该怎么构造？

题外话。。我突然发现max[i]不是只和max[i-1]相关。。怪不得我之前想歪了。。其实f[i]可以依赖于之前所有的解是吧，毕

唔。。不行啊，我要知道max[i-1]结束的时候有没有i-1..不然求max[i]好像num[i]不好加进去

很好，你看，如果直接按照你的定义来求，那么max[i] = max(max[0], max[1], max[2], ..., max[i-1], 还有以第i个元素为结尾的最大子数组和） ， 你觉得这样子的求解对吗？
对！
嗯嗯，但是你很快就发现了，最后一个值没有包含在我们原先对max的含义的定义中，所以这就是为什么我们会引入一个对应这项概念的sum[i]
等等。。max[i]只和max[i-1]有关吧。。和i-2有关系么
Very good，我是故意写成那样的，哈哈。准确来说上面的式子从数学上来说没错，但是没必要，因为我们只需要拿sum[i]和max[i-1]比较就行了，对不？因为g根据我们的定义，max[i]是从0到i-1的原数组中得最大子数组和，所以根据根据最后一个元素，我们可以划分成两个部分，要不解存在在前i-1个元素构成的数组中，要不是以第i号元素结尾的子数组。
对。。所以还是引入一个sum[i]用来辅助画max[i]的状态图是吧
这样我好想一点。。因为老是觉得一个函数写出来，f（x）就应该是答案的感觉。。不过这题的画感觉就用了两个数组，出来max数组，sum数组好像也不能省，是吧。。

你这个观念得变，没有规定一个问题只包含一种状态定义，要根据问题来分析，从递归上来想，按照我们的定义能写出状态转移方程吗，如果不能那就要么修改我们原来的状态定义使其包含更多更准确的信息，要么引入新的状态

对哦。。多弄几个状态也是可以的-    -
那最后再问几个和概念挂钩的。。因为今天一直在读概念。。觉得太绕口了，如果按照我的max的定义，最优子结构怎么说-    -
因为一开始我以为概念不重要。。然后他们说不弄清楚概念的话，给一道题不好判断是不是用DP做，告诉你是DP你会做，但是不告诉你，就比较难了。。这样子。。
人捏人捏

准确来说DP的概念不难，难是难在对于给定的一个问题，如何设计出合理的状态，一般状态设计出来的，状态转移方程就能够出来了，无后效性和最优子结构其实就直接出来了。
最优子结构：max[i]maybe depends on max[i-1]?
当前最优解包含之前的最优解
不知道是不是想歪。。要是前面都是负的，最后一个数是正的。。那max[i]和max[i-1]就没关系了吧。。我钻牛角尖了么。。
有关系啊，你要算max[i]的话，你需不需要利用max[i-1]的结果？
你是说用来作比较么？
Yes
即使不是直接有关系，但是哦哦，我知道了，就是得到max[i]需要max[i-1]的帮助
这就是最优子结构的意思？
嗯嗯，因为你必须先得到子问题的最优解才能得到原问题的最优解
这么说，如果a,b,c 是d的子问题
那么最优子结构的意思就是说d的最优解要包含a,b,c的最优解
无后效性是说，d的最优解包含它的更大的问题的求解策略的影响
重叠子问题是说，d可能要用到a,b,c?
不对，重叠子问题说的是，比如说算c的时候我们依赖于a，b，e，算d的时候我们依赖于a，b，c，在求解过程中，每次产生的子问题并不总是新问题，有些子问题会被重复计算，所以动态规划会按照一定的计算顺序来一边计算一边记录结果，这样像我上边举的例子，算d的时候，我们发现a和b已经算过了，就可以直接利用结果而不需要重复算一遍。这也是为什么我在前面说动态规划是recursion without repetition
^^^^^^因为重叠子问题，所以我们采用数组记录下轨迹为了以后用，是么
不过好像这个题目，不管是max还是sum，并没有重叠子问题。。所以这是为什么说重叠子问题不是动态规划的必要条件？
嗯嗯，但是其实这道题目是由重叠子问题的。你看如果我们不是一边记录一边来算max和sum，而是直接按照递归来做，你可以画图看看递归调用树你就知道了
不过感觉。。没有重叠，就是记录了一次而已。。我是这个意思。。而且被用一次，就没没有用了。。
你这个感觉正是我们用了DP加速后带来的效果，每次计算当前状态i只依赖于之前状态i-1，所以都不用保存所有之前的状态，直接记录上一次状态就可以了

所以这道题还是没有重叠子问题！因为没有重叠！对不对！^^
错，我说了，你如果把之前的算法按照递归实现的话，你画递归调用树就会发现有很多重复计算的子问题
只是我们现在按照这个顺序来一边计算一边记录的话就消去了所有重复的计算罢了
懂了
你是说重叠子问题不是看用了什么算法或者最后实现的代码，而是看问题本身，对吧？。。我又想歪了。。
对，看你问题是怎么递归求解的。再举个例子，比如说我要求一个字符串的最小分割数目使得分割出来的每个子串都是回文串。假设有这样一个字符串， “aa....", 
n那么对于省略号的部分，我们在分割成“aa“和这个子串的时候求了一次，在分割成”a”， “a“和这个子串的时候又求了一次，这个字串在我们递归算法里面就求了两次了，但是我们可以通过缓存这部分的结果来加速。这是所谓重复子问题
不过我。。刚刚想了想。。max这里，重叠子问题。。你说递归调用是说用brute force看看这道题怎么做么
我先把聊天记录保存到git里面

嗯嗯，对于所有DP的问题，我们都可以通过递归来做，只不过由于存在大量重复计算，所以直接递归计算的效率很差。就像那个经典的斐波那契数列的那个例子一样

我笔记本没电了，换了台电脑。。对了，这道题的复杂度，就是一个for循环么。。。网上说DP复杂度都是多项式。。是说几个for循环的意思么。。

你可以这么理解
恩。。我也这么觉得。。一般是说DP自底向上是吗，反正就是朝着目标解的方向走。。我好像没有什么问题了。。

OK




//看这里%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
*****************************************
是这个意思么？
前面一个理解正确，后面一个，对于d的解，一旦确定了，就不再改变，不受在这之后，包含它的更大的问题的求解策略的影响，比如对于a问题，它的最优解就是fixed的了，不会受到d或者其他的问题影响

不受在这之后，包含它的更大的问题的求解策略的影响，这个是吧
嗯嗯
嗯嗯
