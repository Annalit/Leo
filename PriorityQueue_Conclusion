其实可以用priorityqueue来解的题目都有一个明显的一个“挑”的过程。一定在某个地方，它需要从一个queue里面，挑出一个满足条件的。
比如像杨氏矩阵，它的每一次挑，都是从一个queue里面挑一个最小的出来，其实重点在于，这个queue怎么构造。也就是，从哪些里面挑出来。
当然你可以说杨氏矩阵，全部放进priorityqueue里面，然后 挑一个最小的出来，就是当前最小，但是，我们真的需要全部一次性放进
priorityqueue里面么
显然不是，如果从左上角开始，我要选的只有第一个点。但是我接下来加进去的点，分别是它的right和down。
其实priorityqueue的set是非常灵活的，你首先要找的就是最小值域，然后你会发现扩大值域的时候，是非常自然而然的。
就像丑数一样，你当然可以生成一堆数然后从里面挑1，2，3，4，但是我真的一定要生成那么多才能得出第一个数么。
不是的，我只需要2，3，5，就可以得到我的第一个数。
难道我要生成那么多数才能得到我的第二个数么。
下一个数应该在哪些数里面产生，不说2 * 2， 2 * 3， 2* 5，因为你不知道这三个数和3的关系其实，然后加进去。。
然后就想合并k个sortedlist，用二分固然好，不过k个sortedlist平均长度为n整个复杂度是knlogk
换一种思路，直接构造链表。
也就是挑。
那么从哪些里面开始挑呢，我们需要把所有的数放进去么？不，我们要最小化堆的规模，我们发现第一次的数肯定在k个里面产生。。
其实这样规律就出来了。
。。
然后prioriyqueue里面需要注意不能放重复的东西进去，但是可以放priority相等的东西进去。
