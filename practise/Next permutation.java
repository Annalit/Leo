自己脑子不转不想等天上掉馅饼呢。。呵呵
12345
12354
12435
12453
12534
12543
13245
13254
13425
13452
13524
13542
14235
有些啰嗦的想法1:(想法2更好)
其实很简单，什么时候存在next permutation，是不是一直都存在呢
不，54321是没有下一个permutation的
所以存在permutation的前提是存在顺序对
然后根据规则，我肯定从后面往前面改，因为我要保证next permutation是所有permutation中比当前数大的最小值，数字自然从右边改。
所以首先要找最后一个顺序对，假设是A[i],A[i + 1](这个顺序对的后面都是逆序对）
只看[i + 1, A.length - 1]这一段是不存在next permutation的，最后一个顺序对的后面肯定都是逆序的，这一块已经饱和了。
但是因为i和i+1能构成升序对，所以加了A[i]之后整体又存在next permutation了。
根据规则，要从[i + 1, A.length - 1] 数组里面找出一个比当前大的最小数替换掉这个值，字典序的规则
因为i + 1后面都是逆序的,所以从右往左找到第一个比A[i]大的元素。它就是A[i]下一个值，设为A[x]。
那A[i]后面的元素怎么办
因为A[i + 1]后面是逆序的，所以说 只有[i + 1, x]这一个区间是>=x的。
所以可以证明A[i] 和A[x]交换之后，[i + 1, A.length - 1]依然是逆序的
很显然这个时候我需要这个区间需要完全顺序，所以把后面这一块逆序reverse就好了。

想法2:
刚刚写着突然觉得这样想更简单:
简单地说其实就是从start到end，每一个元素依次把自己能取到的最小值到最大值挨个走一遍。。找最后一个升序i,i + 1是因为
A[i]可以取到比自己更大的值。因为i后面存在比它大的元素。所以从后面找到比当前的元素大的最小值来替换它，
然后A[i]变了的话，后面再从小到大走一遍咯~
