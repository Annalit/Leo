public class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int count = 0;
        while(m != n){
            m = m >>1;
            n = n >>1;
            count++;
        }
        return n<<count;
    }
}
位运算真的是很奇妙的东西呀
我觉得这道题最大的收获在于！
m >>= 1 和 m = m >> 1 是等价的
m += 1 和 m = m + 1是等价的。。。
这道题的思路其实也不难想。。不过一开始自己写个循环全部&起来是个什么鬼。。。O(n)太慢了！
显然人家是要O(1)的。
很显然只要有0就是0，所以这道题我们关心的是后面0的个数
什么后面0的个数呢
110001000
100000000
所以你看是第一个不同的bit后面0的个数，换一种思路来想，其实就是右移直到他们完全相同！
所以如果有一道题求两个数左边开始第一位不相同的点，你会发现 bit manipulation是多么感人呀！
